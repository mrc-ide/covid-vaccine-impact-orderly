#' Generate parameter draws from a pmcmc run
#' Code take from squire:::sample_pmcmc()
#' @param out Output of `squire::pmcmc`
#' @param draws Number of draws from mcmc chain. Default = 10
generate_parameters <- function(out, draws = 10){
  #set up parameters
  pmcmc_results <- out$pmcmc_results
  n_trajectories <- draws
  burnin <- 1000
  if("chains" %in% names(out$pmcmc_results)) {
    n_chains <- length(out$pmcmc_results$chains)
  } else {
    n_chains <- 1
  }
  n_particles <- 2
  forecast_days <- 0

  #code from squire: Will need updating if squire undergoes changes
  squire:::assert_pos_int(n_chains)
  if (n_chains == 1) {
    squire:::assert_custom_class(pmcmc_results, "squire_pmcmc")
  } else {
    squire:::assert_custom_class(pmcmc_results, "squire_pmcmc_list")
  }
  squire:::assert_pos_int(burnin)
  squire:::assert_pos_int(n_trajectories)
  squire:::assert_pos_int(n_particles)
  squire:::assert_pos_int(forecast_days)
  if (n_chains > 1) {
    res <- squire::create_master_chain(x = pmcmc_results, burn_in = burnin)
  } else if (n_chains == 1 & burnin > 0) {
    res <- pmcmc_results$results[-seq_along(burnin), ]
  } else {
    res <- pmcmc_results$results
  }
  squire:::assert_neg(res$log_posterior, zero_allowed = FALSE)
  res <- unique(res)
  probs <- exp(res$log_posterior)
  probs <- probs/sum(probs)
  drop <- 0.9
  while (any(is.na(probs))) {
    probs <- exp(res$log_posterior * drop)
    probs <- probs/sum(probs)
    drop <- drop^2
  }
  params_smpl <- sample(x = length(probs), size = n_trajectories,
                        replace = TRUE, prob = probs)
  params_smpl <- res[params_smpl, !grepl("log", colnames(res))]
  #add adjustment for if using weekly data
  if("date" %in% names(pmcmc_results$inputs$data)){
    params_smpl$start_date <- squire:::offset_to_start_date(pmcmc_results$inputs$data$date[1],
                                                            round(params_smpl$start_date))
  } else {
    params_smpl$start_date <- squire:::offset_to_start_date(pmcmc_results$inputs$data$week_start[1],
                                                            round(params_smpl$start_date))
  }
  pars.list <- split(params_smpl, 1:nrow(params_smpl))
  names(pars.list) <- rep("pars", length(pars.list))
  #return the parameters
  return(pars.list)
}

#' A function to reduce redundancy in generate programmes
#' @noRd
generate_draws_inner <- function(out, pars.list, draws = 10, parallel, interventions = NULL, excess = FALSE){
  # handle for no death days
  if(!("pmcmc_results" %in% names(out))) {
    message("`out` was not generated by pmcmc as no deaths for this country. \n",
            "Returning the original object, which assumes epidemic seeded on date ",
            "fits were run")
    return(out)
  }

  # grab information from the pmcmc run
  pmcmc <- out$pmcmc_results
  squire_model <- out$pmcmc_results$inputs$squire_model
  country <- out$parameters$country
  population <- out$parameters$population
  data <- out$pmcmc_results$inputs$data

  # are we drawing in parallel
  if (parallel) {
    suppressWarnings(future::plan(future::multisession()))
  }

  if(!is.null(interventions)){
    #if making a change add that intervention here
    pmcmc$inputs$interventions <- interventions
  }else{
    #else this is the interventions that come with the object
    interventions <- out$interventions
  }

  #--------------------------------------------------------
  # Section 3 of pMCMC Wrapper: Sample PMCMC Results
  #--------------------------------------------------------
  #rename objects to their sample_pmcmc equivalent (so that it is simple to update
  #this code)
  pmcmc_results <- pmcmc
  n_particles <- 2
  forecast_days <- 0
  if(excess){
    log_likelihood <- excess_log_likelihood
  } else {
    log_likelihood <- squire:::calc_loglikelihood
  }
  replicates <- draws
  #recreate params_smpl object
  params_smpl <- rbind(pars.list[[1]], pars.list[[2]])

  #instead of using squire:::sample_pmcmc we use the pars.list values provided
  #the following code is taken from squire:::sample_pmcmc and will need updating
  #if squire undergoes major changes
  message("Sampling from pMCMC Posterior...")
  if (Sys.getenv("SQUIRE_PARALLEL_DEBUG") == "TRUE") {
    traces <- purrr::map(.x = pars.list, .f = log_likelihood,
                         data = pmcmc_results$inputs$data, squire_model = pmcmc_results$inputs$squire_model,
                         model_params = pmcmc_results$inputs$model_params,
                         pars_obs = pmcmc_results$inputs$pars_obs, n_particles = n_particles,
                         forecast_days = forecast_days, interventions = pmcmc_results$inputs$interventions,
                         Rt_args = pmcmc_results$inputs$Rt_args, return = "full")
  } else{
    traces <- furrr::future_map(.x = pars.list, .f = log_likelihood,
                                data = pmcmc_results$inputs$data, squire_model = pmcmc_results$inputs$squire_model,
                                model_params = pmcmc_results$inputs$model_params,
                                pars_obs = pmcmc_results$inputs$pars_obs, n_particles = n_particles,
                                forecast_days = forecast_days, interventions = pmcmc_results$inputs$interventions,
                                Rt_args = pmcmc_results$inputs$Rt_args, return = "full",
                                .progress = TRUE, .options = furrr::furrr_options(seed = NULL))
  }
  num_rows <- unlist(lapply(traces, nrow))
  max_rows <- max(num_rows)
  seq_max <- seq_len(max_rows)
  max_date_names <- rownames(traces[[which.max(unlist(lapply(traces,
                                                             nrow)))]])
  trajectories <- array(NA, dim = c(max_rows, ncol(traces[[1]]),
                                    length(traces)), dimnames = list(max_date_names, colnames(traces[[1]]),
                                                                     NULL))
  for (i in seq_len(length(traces))) {
    trajectories[utils::tail(seq_max, nrow(traces[[i]])), , i] <- traces[[i]]
  }
  pmcmc_samples <- list(trajectories = trajectories, sampled_PMCMC_Results = params_smpl,
              inputs = list(squire_model = pmcmc_results$inputs$squire_model,
                            model_params = pmcmc_results$inputs$model_params,
                            interventions = pmcmc_results$inputs$interventions,
                            data = pmcmc_results$inputs$data, pars_obs = pmcmc_results$inputs$pars_obs))
  class(pmcmc_samples) <- "squire_sample_PMCMC"


  #--------------------------------------------------------
  # Section 4 of pMCMC Wrapper: Tidy Output
  #--------------------------------------------------------

  # create a fake run object and fill in the required elements
  r <- squire_model$run_func(country = country,
                             contact_matrix_set = pmcmc$inputs$model_params$contact_matrix_set,
                             tt_contact_matrix = pmcmc$inputs$model_params$tt_matrix,
                             hosp_bed_capacity = pmcmc$inputs$model_params$hosp_bed_capacity,
                             tt_hosp_beds = pmcmc$inputs$model_params$tt_hosp_beds,
                             ICU_bed_capacity = pmcmc$inputs$model_params$ICU_bed_capacity,
                             tt_ICU_beds = pmcmc$inputs$model_params$tt_ICU_beds,
                             population = population,
                             day_return = TRUE,
                             replicates = 1,
                             time_period = nrow(pmcmc_samples$trajectories))

  # and add the parameters that changed between each simulation, i.e. posterior draws
  r$replicate_parameters <- pmcmc_samples$sampled_PMCMC_Results

  # as well as adding the pmcmc chains so it's easy to draw from the chains again in the future
  r$pmcmc_results <- pmcmc

  # then let's create the output that we are going to use
  names(pmcmc_samples)[names(pmcmc_samples) == "trajectories"] <- "output"
  dimnames(pmcmc_samples$output) <- list(dimnames(pmcmc_samples$output)[[1]], dimnames(r$output)[[2]], NULL)
  r$output <- pmcmc_samples$output

  # and adjust the time as before
  full_row <- match(0, apply(r$output[,"time",],2,function(x) { sum(is.na(x)) }))
  saved_full <- r$output[,"time",full_row]
  if("date" %in% names(data)){
    for(i in seq_len(replicates)) {
      na_pos <- which(is.na(r$output[,"time",i]))
      full_to_place <- saved_full - which(rownames(r$output) == as.Date(max(data$date))) + 1L
      if(length(na_pos) > 0) {
        full_to_place[na_pos] <- NA
      }
      r$output[,"time",i] <- full_to_place
    }
  } else {
    for(i in seq_len(replicates)) {
      na_pos <- which(is.na(r$output[,"time",i]))
      full_to_place <- saved_full - which(rownames(r$output) == as.Date(max(data$week_start))) + 1L
      if(length(na_pos) > 0) {
        full_to_place[na_pos] <- NA
      }
      r$output[,"time",i] <- full_to_place
    }

  }

  # second let's recreate the output
  r$model <- pmcmc_samples$inputs$squire_model$odin_model(
    user = pmcmc_samples$inputs$model_params, unused_user_action = "ignore"
  )

  # we will add the interventions here so that we know what times are needed for projection
  r$interventions <- interventions

  # and fix the replicates
  r$parameters$replicates <- replicates
  r$parameters$time_period <- as.numeric(diff(as.Date(range(rownames(r$output)))))
  r$parameters$dt <- pmcmc$inputs$model_params$dt

  return(r)
}

#' Generate Draws from pmcmc run
#'
#' @param out Output of `squire::pmcmc`
#' @param pars.list Output of generate_parameters().
#' @param draws Number of draws from mcmc chain. Default = 10
#' @param parallel Are simulations done in parallel? Default = TRUE
#' @param noInfectionProtect Should the vaccine prevent infections. Default = FALSE
#' @param excess Use the excess loglikelihood? Default = FALSE
generate_draws <- function(out, pars.list, draws = 10, parallel = TRUE, noInfectionProtect = FALSE, excess = FALSE) {
  if(noInfectionProtect){
    out$odin_parameters$vaccine_efficacy_infection <- matrix(0.5,
                                                             nrow = nrow(out$odin_parameters$vaccine_efficacy_infection),
                                                             ncol = ncol(out$odin_parameters$vaccine_efficacy_infection))
    #scale up protection against disease to keep the same efficacy
    if(any(out$interventions$date_vaccine_efficacy_infection_change != out$interventions$date_vaccine_efficacy_disease_change)){
      "Different efficacy change times against disease and infection"
    }
    trueEff <-
      Map("+",
          out$interventions$vaccine_efficacy_infection,
          Map("*",
              Map("-", 1, out$interventions$vaccine_efficacy_infection),
              out$interventions$vaccine_efficacy_disease
          )
      )
    out$parameters$vaccine_efficacy_disease <- trueEff
    out$interventions$vaccine_efficacy_disease <- trueEff
    out$pmcmc_results$inputs$interventions$vaccine_efficacy_disease <- trueEff

    #set infection efficacy in interventions
    out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection <- lapply(
      out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection, function(x) {
        rep(0,17)
        })
    out$interventions$vaccine_efficacy_infection <- lapply(
      out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection, function(x) {
        rep(0,17)
      })
    # the calc_loglikelihood function samples from the model_params for vaccine pars rather than recalculating
    # so we need to update this here
    out$pmcmc_results$inputs$model_params$vaccine_efficacy_infection <- nimue:::format_ve_i_for_odin(
      vaccine_efficacy_infection = out$interventions$vaccine_efficacy_infection,
      tt_vaccine_efficacy_infection = out$pmcmc_results$inputs$model_params$tt_vaccine_efficacy_infection
      )

    out$pmcmc_results$inputs$model_params$prob_hosp <- nimue:::format_ve_d_for_odin(
      vaccine_efficacy_disease = trueEff,
      tt_vaccine_efficacy_disease = out$pmcmc_results$inputs$model_params$tt_vaccine_efficacy_disease,
      prob_hosp = nimue:::probs$prob_hosp)

    #set relative infectiousness to 1
    out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated <-
      matrix(1,
             nrow = nrow(out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated),
             ncol = ncol(out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated)
             )
    out$odin_parameters$rel_infectiousness_vaccinated <-
      matrix(1,
             nrow = nrow(out$odin_parameters$rel_infectiousness_vaccinated),
             ncol = ncol(out$odin_parameters$rel_infectiousness_vaccinated)
      )
    out$parameters$rel_infectiousness_vaccinated <-
      rep(1, length(out$parameters$rel_infectiousness_vaccinated))
  }
  r <- generate_draws_inner(out, pars.list, draws, parallel, excess = excess)
  return(r)
}

#' Generate Draws from pmcmc run with a counter factual based on vaccines
#'
#' @param out Output of `squire::pmcmc`
#' @param pars.list Output of generate_parameters().
#' @param assignedVaccine The number of doses given to the country at this date.
#' @param vaccineStart The date the vaccination is to start. Should be a character
#' in the format "YYYY-MM-DD". Default = NULL
#' @param draws Number of draws from mcmc chain. Default = 10
#' @param parallel Are simulations done in parallel? Default = TRUE
generate_draws_counterfactual <- function(out, pars.list, assignedVaccine,
                                          vaccineStart = NULL,
                                          draws = 10, parallel = TRUE,
                                          excess = excess) {
  #get interventions
  interventions <- out$interventions
  #get original start date if one not given
  #the current date (one day before so that we hit correct number on the last day)
  if("date" %in% names(out$pmcmc_results$inputs$data)){
    modelEnd <- max(out$pmcmc_results$inputs$data$date) - 1
  } else {
    modelEnd <- max(out$pmcmc_results$inputs$data$week_end) - 1
  }
  if(is.na(vaccineStart)){
    if(sum(interventions$max_vaccine) == 0 & assignedVaccine != 0){
      stop("This country has not begun to give vaccinations, please provide a
           vaccine start date")
    }
    vaccineStart <- min(interventions$date_vaccine_change, modelEnd - 1)
    #the minimum is between these to prevent errors in countries that have started
    #vaccinations on the last date
  }
  # allow number of vaccines to change every day from this time to today
  if(as.Date(vaccineStart) >= modelEnd){
    #a check for if there isn't data up to the end data (for example if using weekly excess)
    date_vaccine_change <- seq(modelEnd - 1, modelEnd, by = 1)
  } else{
    date_vaccine_change <- seq(as.Date(vaccineStart), modelEnd, by = 1)
  }
  # now assign vaccines so that they'll sum to the assignVaccine
  max_vaccine <- seq(0, 2*assignedVaccine/(length(date_vaccine_change)+1),
                                  length.out = length(date_vaccine_change) + 1)

  #add to interventions
  interventions$max_vaccine <- max_vaccine
  interventions$date_vaccine_change <- date_vaccine_change

  #generate results
  r <- generate_draws_inner(out, pars.list, draws, parallel, interventions,
                            excess = excess)

  return(r)
}

#' Generate Deaths Averted
#'
#' @param out Output of `squire::pmcmc`
#' @param draws Number of draws from mcmc chain. Default = 10
#' @param parallel Are simulations done in parallel? Default = TRUE
#' @param counterfactual Which counter-factual to compare to? Default = "No Vaccine",
#' and can take a vector to indicate more than one. Should not include Baseline
#' as this is used to store the baseline (not counterfactual data).
#' @param reduce_age Should the output be aggregated by age? Can be TRUE, FALSE,
#' or "Both" to return values both with the aggregated in a special age_group "Total"
#' @param assignedVaccine A vector of the number of vaccines assigned to the
#' country in each counter factual. If this has length = 1 then this number is
#' given to all counter factuals.
#' @param vaccineStart The dates to start the vaccination campaign in each counter
#' factual. If = NULL then each counter factual is assumed to start when it did
#' in reality, else use NA in a vector to indicate this. If the country has not
#' begun this will be the day before the last observation. Dates should be characters
#' in the format "YYYY-MM-DD". If length=1 this date is given to all counter
#' factuals. Default = NULL.
#' @param noWarnings Suppress warnings around just changing the name of a counter
#' factual. Default  = FALSE.
#' @param direct Should there be an estimate of direct effect of the vaccine, i.e.
#' no protection against infection. Default = FALSE.
#' @param excess Use the excess loglikelihood? Default = FALSE
deaths_averted <- function(out, draws, parallel, counterfactual = "No Vaccine", reduce_age = TRUE,
                           assignedVaccine = 0, vaccineStart = NULL,
                           direct = FALSE, noWarnings = FALSE, excess = FALSE) {
  #error if Baseline in counterfactual
  if(any(c("Baseline","baseline","BASELINE") %in% counterfactual)){
    stop('"Baseline" is a reserved name for a counterfactual, please choose another name')
  }
  #warnings for incorrect assignments
  if(!noWarnings & length(counterfactual) == 1){
    if(assignedVaccine == 0 & counterfactual != "No Vaccine"){
      warning("No vaccines assigned to country, supress this warning with noWarnings = TRUE")
    }
  }
  #errors to inconsistent dimensions
  if(length(assignedVaccine) == 1){
    assignedVaccine <- rep(assignedVaccine, length(counterfactual))
    #if only one value use for all counter factuals
  } else if(length(counterfactual) != length(assignedVaccine)){
    stop("Inconsistent number of counterfactuals and vaccine assignments")
  }
  if(!is.null(vaccineStart)){
    if(length(vaccineStart) == 1){
      vaccineStart <- rep(vaccineStart, length(counterfactual))
      #if only one date use for all counter factuals
    } else if(length(vaccineStart) != length(counterfactual)){
      stop("Inconsistent number of counterfactuals and vaccine start dates")
    }
  } else{
    vaccineStart <- rep(NA, length(counterfactual))
  }


  # return NULL if nothing
  if(!("pmcmc_results" %in% names(out))) {
    return(NULL)
  }

  # get the real data
  data <- out$pmcmc_results$inputs$data
  if("week_start" %in% names(data)){
    data$date <- data$week_start
    out$pmcmc_results$inputs$data$date <- out$pmcmc_results$inputs$data$week_start
  }
  country <- out$parameters$country
  iso3c <- squire::population$iso3c[squire::population$country == country][1]

  #draw the parameters
  pars.list <- generate_parameters(out, draws)

  #Set up the baseline results
  #need to draw this since we need infections (+ maybe age-disaggregated)
  baseline <- generate_draws(out, pars.list, draws, parallel, excess = excess)
  # format the counter factual run
  baseline_deaths <- nimue_format(baseline, c("deaths", "infections"), date_0 = max(data$date),
                                  reduce_age = reduce_age) %>%
    dplyr::distinct() %>%
    tidyr::pivot_wider(names_from = .data$compartment, values_from = .data$y) %>%
    na.omit() %>%
    dplyr::mutate(counterfactual = "Baseline")

  if(!reduce_age){
    baseline_deaths <- dplyr::mutate(baseline_deaths, age_group = as.character(.data$age_group))
  }

  baseline_deaths$t <- NULL

  dataframeLength <- nrow(baseline_deaths)

  #if needed generate the direct effect results
  if(direct){
    baseline_direct <- generate_draws(out, pars.list, draws, parallel, noInfectionProtect = TRUE, excess = excess)
    # format the counter factual run
    baseline_direct_deaths <- nimue_format(baseline_direct, c("deaths", "infections"), date_0 = max(data$date),
                                    reduce_age = reduce_age) %>%
      dplyr::distinct() %>%
      tidyr::pivot_wider(names_from = .data$compartment, values_from = .data$y) %>%
      na.omit() %>%
      dplyr::mutate(counterfactual = "Baseline-Direct")

    if(!reduce_age){
      baseline_direct_deaths <- dplyr::mutate(baseline_direct_deaths, age_group = as.character(.data$age_group))
    }

    baseline_direct_deaths$t <- NULL

    baseline_deaths <- rbind(
      baseline_deaths,
      baseline_direct_deaths
    )
  }

  #set up data frame to hold results
  columns <- ncol(baseline_deaths)
  deaths_df <- as.data.frame(
    matrix(NA,
           ncol = columns,
           nrow = dataframeLength*length(counterfactual))
    )
  names(deaths_df) <- names(baseline_deaths)
  class(deaths_df$date) <- "Date"

  #run the counter-factual
  for(counterIndex in seq_along(counterfactual)){
    #generate draws with pars.list
    counter <- generate_draws_counterfactual(out = out, pars.list = pars.list,
                                             assignedVaccine = assignedVaccine[counterIndex],
                                             vaccineStart = vaccineStart[counterIndex],
                                             draws = draws, parallel = parallel,
                                             excess = excess
                                  )
    #format the counter factual run
    counter_df <- nimue_format(counter, c("deaths", "infections"),
                                   date_0 = max(data$date),
                                   reduce_age = reduce_age) %>%
      dplyr::distinct() %>%
      tidyr::pivot_wider(names_from = .data$compartment, values_from = .data$y) %>%
      na.omit() %>%
      dplyr::mutate(counterfactual = counterfactual[counterIndex])

    if(!reduce_age){
      counter_df <- dplyr::mutate(counter_df, age_group = as.character(.data$age_group))
    }
    counter_df$t <- NULL

    #attach to counter-factual data frame
    deaths_df[seq(dataframeLength) + dataframeLength*(counterIndex-1),] <- counter_df
  }

  #add baseline data
  deaths_df <- rbind(
    deaths_df,
    baseline_deaths
  ) #ADD REMOVED DEATHS

  if(out$interventions$pre_epidemic_isolated_deaths > 0){
    if(reduce_age){
      deaths_df <- rbind(deaths_df,
        expand.grid(replicate = unique(deaths_df$replicate),
                  counterfactual = unique(deaths_df$counterfactual)) %>%
        mutate(
          date = NA,
          deaths = out$interventions$pre_epidemic_isolated_deaths,
          infections = 0
        )
      )
    } else {
      deaths_df <- rbind(deaths_df,
                         expand.grid(replicate = unique(deaths_df$replicate),
                                     counterfactual = unique(deaths_df$counterfactual),
                                     age_group = unique(deaths_df$age_group)) %>%
                           group_by(replicate, counterfactual) %>%
                           mutate(
                             date = NA,
                             deaths = out$interventions$pre_epidemic_isolated_deaths/length(age_group),
                             infections = 0
                           ) %>% ungroup()
      )
    }
  }

  deaths_df <- arrange(deaths_df, counterfactual, replicate, date)


  # and add country info
  deaths_df$country <- country
  deaths_df$iso3c <- iso3c
  return(deaths_df)
}
